#!/bin/bash
# source: https://www.mageta.org/blog/2021/2021.06.04-plasma521-i3.html#starting-child-porcesses-in-app-slice-with-i3
set -euo pipefail

# Defaults
declare -g foreground=false custom_name="" custom_description="" verbose=false
declare -g prefix="drun" slice="desktop-apps.slice" custom_unit=""
declare -g workspace="" tile=false float=false focus=false hypr_batch=""

show_help() {
  cat <<EOF
Usage: $(basename "${0}") [OPTIONS] [--] <command> [args...]

Start a program as systemd transient unit (.scope for background, .service for foreground)
for better resource management, with optional Hyprland dispatcher actions.
OPTIONS:
    -f, --foreground         Run command in foreground (default: background)
    -n, --name <name>        Use custom unit name prefix
    -r, --prefix <prefix>    Use custom prefix (default: drun)
    -s, --slice <slice>      Use custom systemd slice (default: desktop-apps.slice)
    -d, --description <desc> Use custom unit description
    -u, --unit <unit>        Use custom unit name (bypasses name generation)
    -v, --verbose            Enable verbose output
    -h, --help               Show this help message

HYPRLAND OPTIONS:
    -w, --workspace <n>      Move window to specific workspace (always silent)
    -t, --tile               Force window to tile
    -F, --float              Force window to float
    --focus                  Focus on window after moving to workspace
    -b, --batch <cmds>       Additional hyprctl commands (semicolon-separated)

EXAMPLES:
    $(basename "${0}") -- firefox
    $(basename "${0}") --workspace 3 --tile -- firefox
    $(basename "${0}") --float --workspace 2 --focus -- code
    $(basename "${0}") --batch "keyword general:border_size 2;keyword general:gaps_out 20" -- firefox
    $(basename "${0}") --workspace 2 --batch "dispatch pin;keyword windowrule 'float,class:firefox'" -- firefox

AUTOCOMPLETION:
    Bash - Add to ~/.bashrc:
    eval "\$(dr --completion)"

    Fish - Add to ~/.config/fish/config.fish:
    dr --completion fish | source

    Or create completion file:
    dr --completion fish > ~/.config/fish/completions/dr.fish
EOF
}

# Shell completion functions
show_completion() {
  local script_name shell_type
  script_name="$(basename "${0}")"

  # Detect shell type
  if [ -n "${FISH_VERSION:-}" ] || [ "${1:-}" = "fish" ]; then
    shell_type="fish"
  else
    shell_type="bash"
  fi

  case "$shell_type" in
  "fish")
    show_fish_completion "$script_name"
    ;;
  "bash" | *)
    show_bash_completion "$script_name"
    ;;
  esac
}

show_bash_completion() {
  local script_name="$1"

  cat <<'EOF'
_drun_completion() {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    
    # Find if we have -- in the command line
    local dash_dash_pos=-1
    local i
    for ((i=1; i<COMP_CWORD; i++)); do
        if [[ "${COMP_WORDS[i]}" == "--" ]]; then
            dash_dash_pos=$i
            break
        fi
    done
    
    # If we're after --, complete commands and files
    if [[ $dash_dash_pos -ne -1 && $COMP_CWORD -gt $dash_dash_pos ]]; then
        # We're completing the command after --
        if [[ $COMP_CWORD -eq $((dash_dash_pos + 1)) ]]; then
            # Complete executable commands
            local commands
            commands=$(compgen -c -- "$cur" 2>/dev/null)
            COMPREPLY=($commands)
        else
            # Complete files for command arguments
            COMPREPLY=($(compgen -f -- "$cur"))
        fi
        return 0
    fi
    
    # Handle option arguments that expect values
    case "$prev" in
        -n|--name|-d|--description|-r|--prefix|-s|--slice|-u|--unit|-w|--workspace|-b|--batch)
            # These options expect a value, don't complete
            return 0
            ;;
    esac
    
    # Complete script options
    opts="--foreground --name --description --prefix --slice --unit --workspace --tile --float --focus --batch --help --verbose --completion --"
    short_opts="-f -n -d -r -s -u -w -t -F -h -v"
    
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W "$opts $short_opts" -- "$cur"))
    else
        # If no -- yet, suggest it
        COMPREPLY=($(compgen -W "--" -- "$cur"))
    fi
}

# Register the completion function
EOF
  echo "complete -F _drun_completion ${script_name}"
}

show_fish_completion() {
  local script_name="$1"

  cat <<EOF
# Fish completion for ${script_name}

# Define a function to check if we're after --
function __${script_name}_after_doubledash
    set -l cmd (commandline -opc)
    for i in (seq 2 (count \$cmd))
        if test "\$cmd[\$i]" = "--"
            return 0
        end
    end
    return 1
end

# Define a function to get position after --
function __${script_name}_doubledash_pos
    set -l cmd (commandline -opc)
    for i in (seq 2 (count \$cmd))
        if test "\$cmd[\$i]" = "--"
            echo \$i
            return
        end
    end
    echo 0
end

# Complete commands after --
complete -c ${script_name} -n '__${script_name}_after_doubledash' -a '(__fish_complete_command)'

# Complete files for command arguments (when not completing the first command after --)
complete -c ${script_name} -n '__${script_name}_after_doubledash; and test (math (count (commandline -opc)) - (__${script_name}_doubledash_pos)) -gt 1' -F

# Complete script options (before --)
complete -c ${script_name} -n 'not __${script_name}_after_doubledash' -s f -l foreground -d 'Run command in foreground'
complete -c ${script_name} -n 'not __${script_name}_after_doubledash' -s n -l name -d 'Use custom unit name prefix' -r
complete -c ${script_name} -n 'not __${script_name}_after_doubledash' -s d -l description -d 'Use custom unit description' -r
complete -c ${script_name} -n 'not __${script_name}_after_doubledash' -s r -l prefix -d 'Use custom prefix' -r
complete -c ${script_name} -n 'not __${script_name}_after_doubledash' -s s -l slice -d 'Use custom systemd slice' -r
complete -c ${script_name} -n 'not __${script_name}_after_doubledash' -s u -l unit -d 'Use custom unit name' -r
complete -c ${script_name} -n 'not __${script_name}_after_doubledash' -s w -l workspace -d 'Move window to specific workspace' -r
complete -c ${script_name} -n 'not __${script_name}_after_doubledash' -s t -l tile -d 'Force window to tile'
complete -c ${script_name} -n 'not __${script_name}_after_doubledash' -s F -l float -d 'Force window to float'
complete -c ${script_name} -n 'not __${script_name}_after_doubledash' -l focus -d 'Focus on window after moving to workspace'
complete -c ${script_name} -n 'not __${script_name}_after_doubledash' -s b -l batch -d 'Additional hyprctl commands' -r
complete -c ${script_name} -n 'not __${script_name}_after_doubledash' -s h -l help -d 'Show help message'
complete -c ${script_name} -n 'not __${script_name}_after_doubledash' -s v -l verbose -d 'Enable verbose output'
complete -c ${script_name} -n 'not __${script_name}_after_doubledash' -l completion -d 'Show completion script'

# Complete -- separator
complete -c ${script_name} -n 'not __${script_name}_after_doubledash' -a '--' -d 'Command separator'
EOF
}

# Parse arguments
[ "${#}" -lt 1 ] && {
  show_help
  exit 1
}

# Check for completion flag first
if [[ "${1:-}" == "--completion" ]]; then
  show_completion "${2:-}"
  exit 0
fi

opts="$(getopt -o "fn:d:r:s:u:w:tFb:hv" -l "foreground,name:,description:,prefix:,slice:,unit:,workspace:,tile,float,focus,batch:,help,verbose,completion" -n "$(basename "${0}")" -- "${@}")" || {
  echo "Error: Invalid arguments" >&2
  exit 1
}
eval set -- "${opts}"

while true; do
  case "${1}" in
  -f | --foreground) foreground=true ;;
  -n | --name)
    custom_name="${2}"
    shift
    ;;
  -d | --description)
    custom_description="${2}"
    shift
    ;;
  -r | --prefix)
    prefix="${2}"
    shift
    ;;
  -s | --slice)
    slice="${2}"
    shift
    ;;
  -u | --unit)
    custom_unit="${2}"
    shift
    ;;
  -w | --workspace)
    workspace="${2}"
    shift
    ;;
  -t | --tile) tile=true ;;
  -F | --float) float=true ;;
  --focus) focus=true ;;
  -b | --batch)
    hypr_batch="${2}"
    shift
    ;;
  -v | --verbose) verbose=true ;;
  --completion)
    show_completion
    exit 0
    ;;
  -h | --help)
    show_help
    exit 0
    ;;
  --)
    shift
    break
    ;;
  esac
  shift
done

[ "${#}" -eq 0 ] && {
  echo "Error: No command specified" >&2
  show_help
  exit 1
}

declare -ga selection=("${@}")
readonly selection

# Check if stdin is available (not a terminal)
stdin_available=false
if [ ! -t 0 ]; then
  stdin_available=true
fi

# Generate unit name
if [ -n "${custom_unit}" ]; then
  unit_name="${custom_unit}"
else
  if [ -n "${custom_name}" ]; then
    name="${custom_name}"
  else
    read -r -d '' -n 192 name < <(
      basename "${selection[0]}" | tr -c 'a-zA-Z0-9_-' '[_*]' || true
      echo -e '\0' || true
    ) || true
  fi

  max_name_len=$((217 - ${#prefix} - 37))
  [ "${#name}" -eq 0 ] || [ "${#name}" -gt "${max_name_len}" ] && {
    echo "Error: Invalid unit name length" >&2
    exit 125
  }

  uuid="$(uuidgen)" || {
    echo "Error: Failed to generate UUID" >&2
    exit 1
  }
  unit_name="${prefix}-${name}-${uuid}"
fi

# systemd-run args
declare -ga runargs=(--user --collect --slice="${slice}" --unit="${unit_name}")
${verbose} || runargs+=(--quiet)
runargs+=(--description="${custom_description:-Command: ${selection[*]@Q}}")

# Hyprland helpers
need_hyprland_dispatch() {
  [[ -n "${workspace}" || "${tile}" == true || "${float}" == true || "${focus}" == true || -n "${hypr_batch}" ]]
}

build_batch_commands() {
  local pid_var="${1}" commands=()

  ${tile} && commands+=("dispatch settiled pid:${pid_var}")
  ${float} && commands+=("dispatch setfloating pid:${pid_var}")
  [ -n "${workspace}" ] && commands+=("dispatch movetoworkspacesilent ${workspace},pid:${pid_var}")
  ${focus} && commands+=("dispatch focuswindow pid:${pid_var}")

  if [ -n "${hypr_batch}" ]; then
    IFS=';' read -ra extra <<<"${hypr_batch}"
    for x in "${extra[@]}"; do
      x="$(echo "${x}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
      [ -n "$x" ] && commands+=("$x")
    done
  fi

  local IFS='; '
  echo "${commands[*]}"
}

# Verbose logging
if ${verbose}; then
  echo "Unit name: ${unit_name}" >&2
  echo "Command: ${selection[*]@Q}" >&2
  echo "Slice: ${slice}" >&2
  echo "Foreground: ${foreground}" >&2
  echo "Stdin available: ${stdin_available}" >&2
  need_hyprland_dispatch && echo "Hyprland batch: $(build_batch_commands "<pid>")" >&2
fi

# Handle stdin by creating a temporary file if needed
stdin_file=""
cleanup_stdin() {
  [ -n "${stdin_file}" ] && [ -f "${stdin_file}" ] && rm -f "${stdin_file}" || true
}
trap cleanup_stdin EXIT

if ${stdin_available}; then
  stdin_file=$(mktemp) || {
    echo "Error: Failed to create temporary file" >&2
    exit 1
  }
  cat >"${stdin_file}" || {
    echo "Error: Failed to write to temporary file" >&2
    exit 1
  }
fi

unit_cmd=""
if ! ${foreground}; then
  unit_cmd="
    exec 1> >(systemd-cat -t \"${unit_name}\")
    exec 2> >(systemd-cat -t \"${unit_name}\")
  "
fi

# Build command array
if need_hyprland_dispatch; then
  # Use process substitution to preserve main process PID while capturing logs
  unit_cmd+="
    # Background the hyprctl dispatch
    {
      for i in {1..50}; do
        hyprctl clients | grep -q \"pid\":\ \"\$\$\" && break
        sleep 0.1
      done
      hyprctl --batch \"$(build_batch_commands "\$\$")\" 2>/dev/null
    } &
  "
fi

if ${stdin_available}; then
  unit_cmd+="
    exec $(printf '%q ' "${selection[@]}") < $(printf '%q' "${stdin_file}")
  "
else
  unit_cmd+="
    exec $(printf '%q ' "${selection[@]}")
  "
fi

wrapped_selection=(bash -c "${unit_cmd}")

# Execute
if ${foreground}; then
  exec systemd-run --wait "${runargs[@]}" -- "${wrapped_selection[@]}"
else
  # For background execution, start systemd-run and let it handle its own errors
  systemd-run --scope "${runargs[@]}" -- "${wrapped_selection[@]}" &
  background_pid=$!
  ${verbose} && echo "Started in background (PID: $background_pid)" >&2
fi

# Clean up stdin file after systemd-run starts
if ${stdin_available} && ! ${foreground}; then
  # For background processes, we need to delay cleanup slightly
  # to ensure the process can read the file
  (
    sleep 1
    cleanup_stdin
  ) &
  trap - EXIT || true # Remove the trap since we're handling cleanup manually
fi

# Ensure script exits successfully
exit 0
